/*
 * Decompiled with CFR 0_110.
 * 
 * Could not load the following classes:
 *  java.lang.Object
 *  java.math.BigInteger
 */
package ch.bfh.unicrypt.crypto.proofsystem.classes;

import ch.bfh.unicrypt.crypto.proofsystem.abstracts.AbstractProofSystem;
import ch.bfh.unicrypt.crypto.proofsystem.challengegenerator.classes.RandomOracleChallengeGenerator;
import ch.bfh.unicrypt.crypto.proofsystem.challengegenerator.classes.RandomOracleSigmaChallengeGenerator;
import ch.bfh.unicrypt.crypto.proofsystem.challengegenerator.interfaces.ChallengeGenerator;
import ch.bfh.unicrypt.crypto.proofsystem.challengegenerator.interfaces.SigmaChallengeGenerator;
import ch.bfh.unicrypt.crypto.schemes.commitment.classes.GeneralizedPedersenCommitmentScheme;
import ch.bfh.unicrypt.helper.array.interfaces.ImmutableArray;
import ch.bfh.unicrypt.helper.math.MathUtil;
import ch.bfh.unicrypt.math.algebra.dualistic.classes.ZMod;
import ch.bfh.unicrypt.math.algebra.dualistic.classes.ZModElement;
import ch.bfh.unicrypt.math.algebra.general.abstracts.AbstractElement;
import ch.bfh.unicrypt.math.algebra.general.classes.Pair;
import ch.bfh.unicrypt.math.algebra.general.classes.PermutationElement;
import ch.bfh.unicrypt.math.algebra.general.classes.PermutationGroup;
import ch.bfh.unicrypt.math.algebra.general.classes.ProductGroup;
import ch.bfh.unicrypt.math.algebra.general.classes.ProductSet;
import ch.bfh.unicrypt.math.algebra.general.classes.Triple;
import ch.bfh.unicrypt.math.algebra.general.classes.Tuple;
import ch.bfh.unicrypt.math.algebra.general.interfaces.CyclicGroup;
import ch.bfh.unicrypt.math.algebra.general.interfaces.Element;
import ch.bfh.unicrypt.math.algebra.general.interfaces.Group;
import ch.bfh.unicrypt.math.algebra.general.interfaces.Set;
import ch.bfh.unicrypt.math.function.abstracts.AbstractFunction;
import ch.bfh.unicrypt.math.function.classes.ConvertFunction;
import ch.bfh.unicrypt.math.function.classes.PermutationFunction;
import ch.bfh.unicrypt.math.function.classes.ProductFunction;
import ch.bfh.unicrypt.math.function.interfaces.Function;
import ch.bfh.unicrypt.random.classes.PseudoRandomOracle;
import ch.bfh.unicrypt.random.classes.ReferenceRandomByteSequence;
import ch.bfh.unicrypt.random.interfaces.RandomByteSequence;
import ch.bfh.unicrypt.random.interfaces.RandomOracle;
import java.math.BigInteger;

public class PermutationCommitmentProofSystem
extends AbstractProofSystem<ProductGroup, Pair, ProductGroup, Tuple, ProductSet, Tuple> {
    private static final int DEFAULT_KR = 20;
    private final SigmaChallengeGenerator sigmaChallengeGenerator;
    private final ChallengeGenerator eValuesGenerator;
    private final CyclicGroup cyclicGroup;
    private final int size;
    private final int ke;
    private final int kc;
    private final int kr;
    private final Tuple independentGenerators;

    private PermutationCommitmentProofSystem(SigmaChallengeGenerator sigmaChallengeGenerator, ChallengeGenerator eValuesGenerator, CyclicGroup cyclicGroup, int size, int kr, Tuple independentGenerators) {
        this.sigmaChallengeGenerator = sigmaChallengeGenerator;
        this.eValuesGenerator = eValuesGenerator;
        this.cyclicGroup = cyclicGroup;
        this.size = size;
        this.kr = kr;
        this.independentGenerators = independentGenerators;
        this.ke = ((ZMod)((ProductSet)this.eValuesGenerator.getChallengeSpace()).getFirst()).getModulus().subtract(MathUtil.ONE).bitLength();
        this.kc = this.sigmaChallengeGenerator.getChallengeSpace().getModulus().subtract(MathUtil.ONE).bitLength();
    }

    @Override
    protected ProductGroup abstractGetPrivateInputSpace() {
        return ProductGroup.getInstance(PermutationGroup.getInstance(this.size), ProductGroup.getInstance((Group)this.cyclicGroup.getZModOrder(), this.size));
    }

    @Override
    protected ProductGroup abstractGetPublicInputSpace() {
        return ProductGroup.getInstance((Group)this.cyclicGroup, this.size);
    }

    @Override
    protected ProductSet abstractGetProofSpace() {
        return ProductSet.getInstance(this.eValuesGenerator.getChallengeSpace(), ProductGroup.getInstance((Group)this.cyclicGroup, this.size), this.getCommitmentSpace(), this.getChallengeSpace(), this.getResponseSpace());
    }

    public ProductGroup getCommitmentSpace() {
        return ProductGroup.getInstance((Group)this.cyclicGroup, this.size + 3);
    }

    public ZMod getChallengeSpace() {
        return this.sigmaChallengeGenerator.getChallengeSpace();
    }

    public ProductGroup getResponseSpace() {
        return ProductGroup.getInstance(this.cyclicGroup.getZModOrder(), this.cyclicGroup.getZModOrder(), ProductGroup.getInstance((Group)this.cyclicGroup.getZModOrder(), this.size), this.cyclicGroup.getZModOrder(), ProductGroup.getInstance((Group)this.cyclicGroup.getZModOrder(), this.size));
    }

    public Element getEValues(Tuple proof) {
        if (!((ProductSet)this.getProofSpace()).contains(proof)) {
            throw new IllegalArgumentException();
        }
        return proof.getAt(0);
    }

    public Element getBridingCommitment(Tuple proof) {
        if (!((ProductSet)this.getProofSpace()).contains(proof)) {
            throw new IllegalArgumentException();
        }
        return proof.getAt(1);
    }

    public Element getCommitment(Tuple proof) {
        if (!((ProductSet)this.getProofSpace()).contains(proof)) {
            throw new IllegalArgumentException();
        }
        return proof.getAt(2);
    }

    public Element getChallenge(Tuple proof) {
        if (!((ProductSet)this.getProofSpace()).contains(proof)) {
            throw new IllegalArgumentException();
        }
        return proof.getAt(3);
    }

    public Element getResponse(Tuple proof) {
        if (!((ProductSet)this.getProofSpace()).contains(proof)) {
            throw new IllegalArgumentException();
        }
        return proof.getAt(4);
    }

    @Override
    protected Tuple abstractGenerate(Pair privateInput, Tuple publicInput, RandomByteSequence randomByteSequence) {
double now = System.currentTimeMillis();
        PermutationElement pi = (PermutationElement)privateInput.getFirst();
        Tuple sV = (Tuple)privateInput.getSecond();
System.out.println((System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();        
        Tuple eV = (Tuple)this.eValuesGenerator.generate(publicInput);
System.out.println("g pcps challenge " + (System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();
        Element v = this.cyclicGroup.getZModOrder().add(sV);
        Element w = PermutationCommitmentProofSystem.computeInnerProduct(sV, eV);
        Tuple rV = (Tuple)ProductGroup.getInstance((Group)this.cyclicGroup.getZModOrder(), this.size).getRandomElement(randomByteSequence);
        Tuple ePrimeV = (Tuple)PermutationFunction.getInstance((ProductSet)eV.getSet()).apply(eV, pi);
        Element g = this.independentGenerators.getAt(0);
        Element h = this.independentGenerators.getAt(1);
        Element[] cs = new Element[this.size];
        Element[] ds = new Element[this.size];
        ds[0] = rV.getAt(0);
System.out.println((System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();
        for (int i = 0; i < this.size; ++i) {
            Element c_i_1 = i == 0 ? h : cs[i - 1];
            cs[i] = g.selfApply(rV.getAt(i)).apply(c_i_1.selfApply(ePrimeV.getAt(i)));
            if (i <= 0) continue;
            ds[i] = rV.getAt(i).apply(ds[i - 1].selfApply(ePrimeV.getAt(i)));
        }
System.out.println("g pcps selfApply " + (System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();
        Tuple cV = Tuple.getInstance(cs);
        Element d = ds[ds.length - 1];
        ePrimeV = (Tuple)ProductFunction.getInstance((Function)ConvertFunction.getInstance(ePrimeV.getFirst().getSet(), this.cyclicGroup.getZModOrder()), ePrimeV.getLength()).apply((Element)ePrimeV);
        PreimageProofFunction f = new PreimageProofFunction(this.cyclicGroup, this.size, this.getResponseSpace(), this.getCommitmentSpace(), this.independentGenerators, cV);
        Tuple randomElement = this.getResponseSpace().extractPrefix(4).getRandomElement(randomByteSequence);
        Tuple randEV = (Tuple)ProductGroup.getInstance((Group)ZMod.getInstance(MathUtil.powerOfTwo(this.ke + this.kc + this.kr)), this.size).getRandomElement(randomByteSequence);
        Element[] randEVs = new Element[this.size];

        for (int i2 = 0; i2 < randEVs.length; ++i2) {
            randEVs[i2] = this.cyclicGroup.getZModOrder().getElement(randEV.getAt(i2).convertToBigInteger().mod(this.cyclicGroup.getOrder()));
        }

        randEV = Tuple.getInstance(randEVs);        
        randomElement = randomElement.append(Tuple.getInstance(randEV));
System.out.println((System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();
        Element commitment = f.apply((Element)randomElement);
System.out.println("g pcps function apply " + (System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();
        Element challenge = this.sigmaChallengeGenerator.generate(Pair.getInstance(publicInput, cV), commitment);

        Element response = randomElement.apply(Tuple.getInstance(v, w, rV, d, ePrimeV).selfApply(challenge));
System.out.println((System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();   
        Triple preimageProof = Triple.getInstance(commitment, challenge, response);
        return Tuple.getInstance(eV, cV).append((ImmutableArray)preimageProof);
    }

    @Override
    protected boolean abstractVerify(Tuple proof, Tuple publicInput) {
double now = System.currentTimeMillis();        
        Tuple cV = (Tuple)proof.getAt(1);
        Tuple commitment = (Tuple)proof.getAt(2);
        Tuple response = (Tuple)proof.getAt(4);
System.out.println((System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();         
        Tuple eV = (Tuple)this.eValuesGenerator.generate(publicInput);
System.out.println("v pcps challenge " + (System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis(); 
        Tuple gV = this.independentGenerators.extract(1, this.size);
        Element[] ps = new Element[this.size + 3];
        ps[0] = this.cyclicGroup.apply((ImmutableArray)publicInput).applyInverse(this.cyclicGroup.apply((ImmutableArray)gV));
System.out.println((System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();         
        ps[1] = PermutationCommitmentProofSystem.computeInnerProduct(publicInput, eV);
System.out.println("v pcps compute inner " + (System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis(); 
        for (int i = 0; i < this.size; ++i) {
            ps[i + 2] = cV.getAt(i);
        }
        Element eProd = this.cyclicGroup.getZModOrder().getElement(eV.getAt(0).convertToBigInteger().mod(this.cyclicGroup.getOrder()));
        for (int i2 = 1; i2 < this.size; ++i2) {
            eProd = eProd.selfApply(eV.getAt(i2));
        }
        ps[this.size + 2] = cV.getAt(this.size - 1).applyInverse(gV.getAt(0).selfApply((Element<BigInteger>)eProd));
        Tuple pV = Tuple.getInstance(ps);
        PreimageProofFunction f = new PreimageProofFunction(this.cyclicGroup, this.size, this.getResponseSpace(), this.getCommitmentSpace(), this.independentGenerators, cV);
        Element challenge = this.sigmaChallengeGenerator.generate(Pair.getInstance(publicInput, cV), commitment);
System.out.println((System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis();         
        Element left = f.apply((Element)response);
System.out.println("v pcps function apply " + (System.currentTimeMillis() - now) / 1000.0); now = System.currentTimeMillis(); 
        Element right = commitment.apply((Element)pV.selfApply(challenge));
        return left.isEquivalent((Element)right);
    }

    private static Element computeInnerProduct(Tuple t1, Tuple t2) {
        if (!((ProductSet)t1.getSet()).isGroup() || t1.getArity() < 1) {
            throw new IllegalArgumentException();
        }
        Element innerProduct = ((Group)((ProductSet)t1.getSet()).getAt(0)).getIdentityElement();
        for (int i = 0; i < t1.getArity(); ++i) {
            innerProduct = innerProduct.apply(t1.getAt(i).selfApply(t2.getAt(i)));
        }
        return innerProduct;
    }

    public static PermutationCommitmentProofSystem getInstance(CyclicGroup cyclicGroup, int size) {
        return PermutationCommitmentProofSystem.getInstance(PermutationCommitmentProofSystem.createNonInteractiveSigmaChallengeGenerator(cyclicGroup.getZModOrder()), PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(cyclicGroup.getZModOrder(), size), cyclicGroup, size, 20, ReferenceRandomByteSequence.getInstance());
    }

    public static PermutationCommitmentProofSystem getInstance(CyclicGroup cyclicGroup, int size, ReferenceRandomByteSequence rrbs) {
        return PermutationCommitmentProofSystem.getInstance(PermutationCommitmentProofSystem.createNonInteractiveSigmaChallengeGenerator(cyclicGroup.getZModOrder()), PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(cyclicGroup.getZModOrder(), size), cyclicGroup, size, 20, rrbs);
    }

    public static PermutationCommitmentProofSystem getInstance(CyclicGroup cyclicGroup, int size, Element proverId, int ke, int kc, int kr, ReferenceRandomByteSequence rrbs) {
        return PermutationCommitmentProofSystem.getInstance(PermutationCommitmentProofSystem.createNonInteractiveSigmaChallengeGenerator(kc, proverId), PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(ke, size), cyclicGroup, size, kr, rrbs);
    }

    public static PermutationCommitmentProofSystem getInstance(SigmaChallengeGenerator sigmaChallengeGenerator, ChallengeGenerator eValuesGenerator, CyclicGroup cyclicGroup, int size) {
        return PermutationCommitmentProofSystem.getInstance(sigmaChallengeGenerator, eValuesGenerator, cyclicGroup, size, 20, ReferenceRandomByteSequence.getInstance());
    }

    public static PermutationCommitmentProofSystem getInstance(SigmaChallengeGenerator sigmaChallengeGenerator, ChallengeGenerator eValuesGenerator, CyclicGroup cyclicGroup, int size, int kr, ReferenceRandomByteSequence referenceRandomByteSequence) {
        if (cyclicGroup == null || size < 1 || referenceRandomByteSequence == null) {
            throw new IllegalArgumentException();
        }
        Tuple generators = cyclicGroup.getIndependentGenerators(size, referenceRandomByteSequence);
        return PermutationCommitmentProofSystem.getInstance(sigmaChallengeGenerator, eValuesGenerator, generators, kr);
    }

    public static PermutationCommitmentProofSystem getInstance(Tuple independentGenerators) {
        if (independentGenerators == null || independentGenerators.getArity() < 2 || !independentGenerators.getFirst().getSet().isCyclic()) {
            throw new IllegalArgumentException();
        }
        CyclicGroup cyclicGroup = (CyclicGroup)independentGenerators.getFirst().getSet();
        int size = independentGenerators.getArity() - 1;
        return PermutationCommitmentProofSystem.getInstance((SigmaChallengeGenerator)PermutationCommitmentProofSystem.createNonInteractiveSigmaChallengeGenerator(cyclicGroup.getZModOrder()), (ChallengeGenerator)PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(cyclicGroup.getZModOrder(), size), independentGenerators, 20);
    }

    public static PermutationCommitmentProofSystem getInstance(Tuple independentGenerators, Element proverId, int ke, int kc, int kr) {
        if (independentGenerators == null || independentGenerators.getArity() < 2 || !independentGenerators.getFirst().getSet().isCyclic()) {
            throw new IllegalArgumentException();
        }
        int size = independentGenerators.getArity() - 1;
        return PermutationCommitmentProofSystem.getInstance((SigmaChallengeGenerator)PermutationCommitmentProofSystem.createNonInteractiveSigmaChallengeGenerator(kc, null), (ChallengeGenerator)PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(ke, size), independentGenerators, kr);
    }

    public static PermutationCommitmentProofSystem getInstance(SigmaChallengeGenerator sigmaChallengeGenerator, ChallengeGenerator eValuesGenerator, Tuple independentGenerators, int kr) {
        if (sigmaChallengeGenerator == null || eValuesGenerator == null || independentGenerators == null || independentGenerators.getArity() < 2 || !((ProductSet)independentGenerators.getSet()).isUniform() || !independentGenerators.getFirst().getSet().isCyclic() || kr < 1) {
            throw new IllegalArgumentException();
        }
        CyclicGroup cyclicGroup = (CyclicGroup)independentGenerators.getFirst().getSet();
        if (sigmaChallengeGenerator.getChallengeSpace().getOrder().compareTo(cyclicGroup.getOrder()) > 0) {
            throw new IllegalArgumentException();
        }
        int size = independentGenerators.getArity() - 1;
        Set cs = eValuesGenerator.getChallengeSpace();
        if (!cs.isProduct() || ((ProductSet)cs).getArity() != size || ((ProductSet)cs).getFirst().getOrder().compareTo(cyclicGroup.getOrder()) > 0 || !((ProductSet)cs).isUniform()) {
            throw new IllegalArgumentException();
        }
        return new PermutationCommitmentProofSystem(sigmaChallengeGenerator, eValuesGenerator, cyclicGroup, size, kr, independentGenerators);
    }

    public static RandomOracleSigmaChallengeGenerator createNonInteractiveSigmaChallengeGenerator(ZMod challengeSpace) {
        return PermutationCommitmentProofSystem.createNonInteractiveSigmaChallengeGenerator(challengeSpace, (Element)null, (RandomOracle)PseudoRandomOracle.getInstance());
    }

    public static RandomOracleSigmaChallengeGenerator createNonInteractiveSigmaChallengeGenerator(int kc, Element proverId) {
        return PermutationCommitmentProofSystem.createNonInteractiveSigmaChallengeGenerator(kc, proverId, (RandomOracle)PseudoRandomOracle.getInstance());
    }

    public static RandomOracleSigmaChallengeGenerator createNonInteractiveSigmaChallengeGenerator(int kc, Element proverId, RandomOracle randomOracle) {
        if (kc < 1) {
            throw new IllegalArgumentException();
        }
        ZMod cs = ZMod.getInstance(MathUtil.powerOfTwo(kc));
        return RandomOracleSigmaChallengeGenerator.getInstance(cs, proverId, randomOracle);
    }

    public static RandomOracleSigmaChallengeGenerator createNonInteractiveSigmaChallengeGenerator(ZMod challengeSpace, Element proverId, RandomOracle randomOracle) {
        if (challengeSpace == null) {
            throw new IllegalArgumentException();
        }
        return RandomOracleSigmaChallengeGenerator.getInstance(challengeSpace, proverId, randomOracle);
    }

    public static RandomOracleChallengeGenerator createNonInteractiveEValuesGenerator(int ke, int size) {
        return PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(ke, size, (RandomOracle)PseudoRandomOracle.getInstance());
    }

    public static RandomOracleChallengeGenerator createNonInteractiveEValuesGenerator(int ke, int size, RandomOracle randomOracle) {
        if (size < 1 || ke < 1) {
            throw new IllegalArgumentException();
        }
        return PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(ZMod.getInstance(MathUtil.powerOfTwo(ke)), size, randomOracle);
    }

    public static RandomOracleChallengeGenerator createNonInteractiveEValuesGenerator(ZMod challengeSpace, int size) {
        return PermutationCommitmentProofSystem.createNonInteractiveEValuesGenerator(challengeSpace, size, (RandomOracle)PseudoRandomOracle.getInstance());
    }

    public static RandomOracleChallengeGenerator createNonInteractiveEValuesGenerator(ZMod challengeSpace, int size, RandomOracle randomOracle) {
        if (challengeSpace == null || size < 1) {
            throw new IllegalArgumentException();
        }
        ProductGroup cs = ProductGroup.getInstance((Group)challengeSpace, size);
        return RandomOracleChallengeGenerator.getInstance((Set)cs, randomOracle);
    }

    private class PreimageProofFunction
    extends AbstractFunction<PreimageProofFunction, ProductGroup, Tuple, ProductGroup, Tuple> {
        private final CyclicGroup cyclicGroup;
        private final int size;
        private final Tuple cV;
        private final GeneralizedPedersenCommitmentScheme gpcs;
        private final Element g;
        private final Element h;

        protected PreimageProofFunction(CyclicGroup cyclicGroup, int size, ProductGroup domain, ProductGroup coDomain, Tuple independentGenerators, Tuple cV) {
            super(domain, coDomain);
            this.cyclicGroup = cyclicGroup;
            this.size = size;
            this.cV = cV;
            this.g = independentGenerators.getAt(0);
            this.h = independentGenerators.getAt(1);
            this.gpcs = GeneralizedPedersenCommitmentScheme.getInstance(this.g, independentGenerators.extract(1, size));
        }

        @Override
        protected Tuple abstractApply(Tuple element, RandomByteSequence randomByteSequence) {
            int i;
            Element v = element.getAt(0);
            Element w = element.getAt(1);
            Tuple rV = (Tuple)element.getAt(2);
            Element d = element.getAt(3);
            Tuple ePrimeV = (Tuple)element.getAt(4);
            Element[] pV = new Element[this.size + 3];
            pV[0] = this.gpcs.getRandomizationGenerator().selfApply(v);
            Element[] ePrimeVs = new Element[ePrimeV.getArity()];
            ZMod zMod = this.cyclicGroup.getZModOrder();
            for (i = 0; i < ePrimeV.getArity(); ++i) {
                ePrimeVs[i] = zMod.getElement(((BigInteger)((ZModElement)ePrimeV.getAt(i)).getValue()).mod(zMod.getOrder()));
            }
            pV[1] = this.gpcs.commit(Tuple.getInstance(ePrimeVs), w);
            for (i = 0; i < this.size; ++i) {
                Element c_i_1 = i == 0 ? this.h : this.cV.getAt(i - 1);
                pV[i + 2] = this.g.selfApply(rV.getAt(i)).apply(c_i_1.selfApply(ePrimeV.getAt(i)));
            }
            pV[this.size + 2] = this.gpcs.getRandomizationGenerator().selfApply(d);
            return Tuple.getInstance(pV);
        }
    }

}

